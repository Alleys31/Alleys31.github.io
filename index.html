<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"alleys31.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="小王的各种日常记录">
<meta property="og:type" content="website">
<meta property="og:title" content="小王的小窝">
<meta property="og:url" content="https://alleys31.github.io/index.html">
<meta property="og:site_name" content="小王的小窝">
<meta property="og:description" content="小王的各种日常记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="小王同学">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://alleys31.github.io/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>小王的小窝</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">小王的小窝</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">小王同学</p>
  <div class="site-description" itemprop="description">小王的各种日常记录</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alleys31.github.io/2025/06/06/IP%E5%9C%B0%E5%9D%80%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小王同学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小王的小窝">
      <meta itemprop="description" content="小王的各种日常记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 小王的小窝">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/06/IP%E5%9C%B0%E5%9D%80%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">IP地址详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-06 19:51:17 / 修改时间：19:53:13" itemprop="dateCreated datePublished" datetime="2025-06-06T19:51:17+08:00">2025-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">技术博客</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是IP地址？"><a href="#什么是IP地址？" class="headerlink" title="什么是IP地址？"></a>什么是IP地址？</h1><p>在<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45518315/article/details/147983192">计算机网络入门（一）</a>中，我们已经知道了，在网络中两台设备之间要想完成信息交流，那两个设备就必须配置正确的网络地址，也叫IP地址。IP地址的主要作用就是实现不同子网之间设备的网络通信，具体是怎么实现的呢？我们慢慢来看，首先先要认识一下IP地址的格式（本文特指IPv4）</p>
<h1 id="IP地址的格式"><a href="#IP地址的格式" class="headerlink" title="IP地址的格式"></a>IP地址的格式</h1><p>IP地址由32位二进制数组成，而为了方便人类理解记忆，一般展示为每8位用<code>.</code>隔开，分成4组，并且将每一组转换为十进制形式。如：</p>
<blockquote>
<p>11000000 10101000 00000001 00000001<br>这样一个IP地址，可以写为： 192.168.1.1</p>
</blockquote>
<p>所以互联网上最多可以分配的IP地址数量为：2^32&#x3D;4294967296个，大约43亿</p>
<p>但是决定IP地址的数量的并不是网络设备的数量，而是网卡的数量。一些路由器、服务器等设备一般都包含多块网卡，且现在我们的智能手机、平板电脑等也都有网卡，按道理来讲，互联网上的IP数量应该远远不止43亿了，那IP地址是如何分配，才能容纳这么多的设备呢？</p>
<h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p>NAT(Network Address Translation, 网络地址转换)是一种网络技术，用于将私有网络中的内部IP地址转换为公网IP地址，从而实现内部网络与外部网络（如互联网）之间的通信。</p>
<p>简单来说，在一个子网络内，每个设备都有一个<code>私有IP地址</code>，私有IP地址的格式与公网IP地址一致，但是私有IP地址不能直接用于在互联网上交流，只是用来标记子网络内不同设备。当一个设备向互联网发送请求时，请求消息会首先经过<code>NAT设备</code>，将私有IP地址转换为真正的公网IP地址，这样就可以与公网进行消息交换了。</p>
<p>在NAT设备上，通过不同的端口号来区分来自不同私有IP地址的消息，以便将消息正确的转发。这样，一个公网IP便可以对应多个私有IP地址，这样就解决了公网IP地址有限的问题，避免设备数量过多导致IP地址不够分。</p>
<h1 id="如何判断两个设备是否在同一子网？"><a href="#如何判断两个设备是否在同一子网？" class="headerlink" title="如何判断两个设备是否在同一子网？"></a>如何判断两个设备是否在同一子网？</h1><h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><p>CIDR（Classless Inter-Domain Routing，无类域间路由）是一种用于 IP地址表示与网络划分 的方法，它规定IP地址的表示形式为：</p>
<blockquote>
<p>IP地址&#x2F;子网长度</p>
</blockquote>
<p>例如：</p>
<blockquote>
<p>192.168.0.0&#x2F;16</p>
</blockquote>
<p>IP地址我们上面已经学习过了，那子网长度又是什么呢？</p>
<p>首先我们先来了解一下子网掩码的概念</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>子网掩码是为了区分不同的子网络引入的概念，与IP地址一样，子网掩码也是由32位二进制数组成，不同的是，子网掩码必须由连续的若干个1开始，后跟连续的若干个0，0和1不能交叉出现，例如：</p>
<blockquote>
<p>11111111 00000000 11111111 00000000<br>11110000 10101010 00000000 00000000<br>11111111 11111111 11111110 10000010</p>
</blockquote>
<p>这些都不是正确的子网掩码格式</p>
<p>而下面是一个正确的子网掩码格式：</p>
<blockquote>
<p>11111111 11111111 00000000 00000000</p>
</blockquote>
<p>和IP地址一样，上面的子网掩码也可以人性化表示为：</p>
<blockquote>
<p>255.255.0.0</p>
</blockquote>
<p>那么怎么使用子网掩码来区分两个IP地址是否在同一子网中呢？答案是<code>按位与</code><br>假如有两个IP地址：192.168.0.1和192.168.1.0，子网掩码为255.255.0.0，首先我们将它们写成二进制形式：</p>
<blockquote>
<p>192.168.0.1: 11000000 10101000 00000000 00000001<br>192.168.1.0: 11000000 10101000 00000001 00000000<br>255.255.0.0: 11111111 11111111 00000000 00000000</p>
</blockquote>
<p>分别将两个IP地址与子网掩码进行按为与操作，我们发现两个结果均为：</p>
<blockquote>
<p>11000000 10101000 00000000 00000000</p>
</blockquote>
<p>这两个IP得到的结果是相同的，则说明它们在同一个子网中，而得到的这个结果，称为<code>网络号</code></p>
<p>所以可以得到结论，在子网掩码为255.255.0.0时，192.168.0.1与192.168.1.0属于同一个子网，网络号为192.168.0.0</p>
<p>由于子网掩码的特性为一定是连续的若干个1后跟连续的若干个0，所以子网掩码也可以用一个更简单的方式来表达，那就是上面所说的<code>子网长度</code>，即子网掩码中1的数量，例如255.255.0.0，其中包含了16个1，因此子网长度为16，因此上面的子网络可以表示为</p>
<blockquote>
<p>192.168.0.0&#x2F;16</p>
</blockquote>
<p>它代表了一个子网络的IP地址范围，其中包含了192.168.0.0-192.168.255.255这一系列IP地址</p>
<p>特别地，当子网长度为32时，例如192.168.125.131&#x2F;32，就表示了一个具体的IP地址</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alleys31.github.io/2025/05/25/ActiveMQ%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小王同学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小王的小窝">
      <meta itemprop="description" content="小王的各种日常记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 小王的小窝">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/25/ActiveMQ%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">ActiveMQ僵尸进程问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-05-25 11:07:02 / 修改时间：11:07:56" itemprop="dateCreated datePublished" datetime="2025-05-25T11:07:02+08:00">2025-05-25</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天在工作时接到需求，在已有业务镜像的基础上，在里面加一个ActiveMQ服务，于是我将ActiveMQ的包打入镜像中，并在业务的启动脚本里添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ps -ef | grep -v grep | grep -q activemq</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ];<span class="keyword">then</span></span><br><span class="line">    activemq console &amp;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>由于我对ActiveMQ并不了解，采用了 <code>activemq console &amp;</code> 这样的方式，试图将activemq起在后台，结果发现容器启动后发现activemq进程并没有正常运行，而是产生了一系列僵尸进程。</p>
<h2 id="为什么会产生僵尸进程？"><a href="#为什么会产生僵尸进程？" class="headerlink" title="为什么会产生僵尸进程？"></a>为什么会产生僵尸进程？</h2><p>首先我去了解了一下僵尸进程产生的原因：</p>
<blockquote>
<p>   在 Unix&#x2F;Linux 系统中，正常情况下，子进程是通过父进程创建的，且两者的运行是相互独立的，父进程永远无法预测子进程到底什么时候结束。当一个进程结束或退出时，其实它并没有真正的被销毁，操作系统内核只是释放了该进程的所有资源，但是留下一个“躯壳”，这个“躯壳”保留了一定的信息（包括进程号 the process ID，退出状态，运行时间），这些信息只有父进程通过 wait()&#x2F;waitpid() 来取时才释放，这个“躯壳”就叫做僵尸进程。</p>
</blockquote>
<p>也就是说，子进程结束或退出后，它的父进程没有执行wait()&#x2F;waitpid()方法回收它，就会变成僵尸进程。</p>
<p>通过查阅资料，Java程序一般都不会主动做子进程的回收，不会定期调用wait()&#x2F;waitpid()方法回收退出的子进程，而通过今天遇到的问题现象，很明显，ActiveMQ也没有。</p>
<p>正常情况下，shell会等待它的子进程退出，并执行wait()进行回收，一般不会产生僵尸进程问题。</p>
<p>而我使用<code>activemq console &amp;</code>方式将activemq进程放在了后台运行，shell便不会等待并回收该进程，因此导致了activemq进程“无人管理”，所以出现了僵尸进程。</p>
<p>但是实际上如果在物理机上，一般操作系统都有完整的init系统(如systemd)，init系统会自动定期清理子进程，所以正常情况也不会有长期存在的僵尸进程，但是在容器中，我的一号进程为该镜像原本的业务进程，它并不负责进程的回收，所以最终导致了僵尸进程的产生。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol>
<li>使用<code>activemq start</code> 命令，此命令是activemq专门用来启动后台进程的命令，其后台自动启动了进程管理服务来管理子进程，不会产生僵尸进程问题</li>
<li>直接使用<code>activemq console</code>在前台运行，让它的父进程(一般是bash)来做子进程的回收</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alleys31.github.io/2025/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小王同学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小王的小窝">
      <meta itemprop="description" content="小王的各种日常记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 小王的小窝">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">计算机网络入门（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-16 18:54:00" itemprop="dateCreated datePublished" datetime="2025-05-16T18:54:00+08:00">2025-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-18 21:16:56" itemprop="dateModified" datetime="2025-05-18T21:16:56+08:00">2025-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">技术博客</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="在浏览器输入一个网址，按下回车后，到底都发生了什么？"><a href="#在浏览器输入一个网址，按下回车后，到底都发生了什么？" class="headerlink" title="在浏览器输入一个网址，按下回车后，到底都发生了什么？"></a>在浏览器输入一个网址，按下回车后，到底都发生了什么？</h1><p><a href="https://alleys31.github.io/2025/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/">上一篇文章</a>，我们已经了解了网络的基本组成结构，以及每一层分别实现了什么功能。今天，我们将深入探索，详细看看在网络传输中的每一个环节都发生了什么。</p>
<p>我们在上网时，在浏览器输入一个网址，按下回车键，我们想要的页面就展示出来了，那你们有没有想过，在按下回车键之后，都发生了什么呢？</p>
<p>我们今天就来详细看看。假如我在浏览器界面输入了这样一个网址<br><a href="https://alleys31.github.io/2025/05/15/homepage">https://alleys31.github.io/2025/05/15/homepage</a><br>按下回车后都发生了什么呢？</p>
<h2 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h2><p>要讲网络通信，绕不开的一个概念就是URL。什么是URL呢？</p>
<p>URL（Uniform Resource Locator，统一资源定位符），用于定位互联网上资源的地址。它由多个部分组成，包括协议、域名、路径和查询参数等，用于唯一标识和访问网络上的资源。</p>
<p>一个URL的基本构成为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议://主机:端口/要访问的资源路径?查询参数</span><br></pre></td></tr></table></figure>

<ul>
<li>协议：指定访问资源所使用的协议，如http、https、ftp等。</li>
<li>主机：标识资源所在的服务器，如<a target="_blank" rel="noopener" href="http://www.example.com./">www.example.com。</a></li>
<li>端口：指定服务器上的端口号，通常默认端口可以省略，如80（HTTP）或443（HTTPS）。</li>
<li>路径：指定服务器上资源的具体位置，如&#x2F;path&#x2F;to&#x2F;resource。</li>
<li>查询参数：用于传递额外的信息，多个参数用&amp;分隔，如?key1&#x3D;value1&amp;key2&#x3D;value2。</li>
</ul>
<hr>
<p>这个结构是不是很眼熟？没错，实际上，我们刚才输入的网址就是一个URL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://alleys31.github.io/2025/05/15/homepage</span><br></pre></td></tr></table></figure>
<p>既然已经知道了URL的组成结构，那么现在我们就可以理解这个网址的含义了。</p>
<p>我们使用了https协议，访问alleys31.github.io这台主机的443端口上的服务，要访问的是主机上&#x2F;2025&#x2F;05&#x2F;15&#x2F;homepage这个文件的内容。</p>
<blockquote>
<p>明确要“传什么”——这就是<strong>应用层</strong>负责的功能。</p>
</blockquote>
<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>通过分析URL，我们知道了要访问的是<code>alleys31.github.io</code>这台主机，而我们知道，定位一个网络设备需要的是IP地址，而这里的<code>alleys31.github.io</code>相当于是一个“别名”，我们称之为<code>域名</code>。我们需要知道这个域名对应的IP地址是什么，才能在网络中定位到该主机。</p>
<p>在网络中，有一种服务器，它们专门保存了 Web 服务器域名与 IP地址的对应关系，它们就是 DNS服务器。</p>
<p>域名的构造结构有什么规范？DNS服务器具体是如何根据域名查出对应的IP地址的？<br>这里<a href="">留一个坑</a>，后续我将单独写一篇笔记来学习。</p>
<p>通过DNS服务的帮助，现在我们已经知道了待访问的主机的IP地址了，假设为185.199.110.153</p>
<hr>
<p>通过上面的步骤，我们现在已经明确了本次网络传输的目标：我们当前浏览器程序占用的端口（一般为随机端口）向185.199.110.153这台服务器的443端口发送请求，访问服务器上的&#x2F;2025&#x2F;05&#x2F;15&#x2F;homepage文件内容。接下来就可以正式开始信息的传输过程了。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>应用层的下一层为传输层，我们知道，传输层负责的功能是实现<code>端口到端口</code>的通信，因此TCP传输的报文<code>头部</code>就包含了发送方及接收方的端口号，除此以外根据协议不同还有其他字段，本笔记仅作入门，头部的具体格式这里不做详解。</p>
<p>传输层将需要<code>传输的数据内容</code>和<code>头部</code>打包起来，构成传输层报文，发往下一层。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>传输层负责的是端口到端口的通信，而网络层负责的是主机到主机的通信，网络层的报文头部包含了发送方及接收方的IP地址，网络层将传输层发来的报文进一步包装，加上IP头部，继续发往下一层。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>和前两层类似的，在数据链路层需要给报文加上发送方和接收方的MAC地址，而MAC地址该如何获取呢？</p>
<p>发送方的MAC地址比较容易获得，就是本机网卡的MAC地址<br>接收方的MAC地址就比较麻烦了，因为我们只知道目标的IP地址，并不知道它的MAC地址。这时就需要另一个协议来发挥作用了——ARP（Address Resolution Protocol，地址解析协议）。</p>
<p>根据ARP 协议，我们首先判断目标IP地址是否与我们在同一子网中，如果是，主机会以广播的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”，这样，符合要求的主机就会将自己的MAC地址发送回来。</p>
<p>那如果没有在一个子网呢？那也很简单，根据路由表可以查出目标IP需要通过哪个网关（gateway）发出，我们的接收方MAC地址即为该网关的MAC地址。</p>
<blockquote>
<p>每次获取MAC地址都要这样查询，这样岂不是很麻烦，而且会影响传输的效率呀？</p>
</blockquote>
<p>放心，ARP对此已经做了考虑，操作系统会把本次查询结果放到一块叫做<code>ARP 缓存</code>的内存空间留着以后用。</p>
<p>下次再需要查询MAC地址时，操作系统首先会检查ARP缓存的内容，如果ARP缓存中有该IP对应的MAC地址信息，就直接取用，ARP缓存中没有才会去广播查询。</p>
<p>在拿到发送方和接收方的MAC地址后，数据链路层对网络层发来的报文进行进一步封装，组成最终的报文形式。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>我们封装完成的数据报文是一组二进制的数字信息形式，想要在网线上传输，还需要把它们转换成电信号，这一过程由网卡来执行。网卡将待发送的数据转换为电信号，通过网线发出，至此，数据包才真正离开了我们的电脑。</p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>数据包离开主机后到达的第一站就是交换机。交换机是什么呢？</p>
<p>我们知道，网络就是由若干网络设备连接在一起组成的，那么它们之间是怎么连接的呢？总不能直接把我的电脑用一根线和别人的电脑连在一起，或者是直接把我的电脑插在路由器上吧？所以我们就需要有一个“中转站”，这就是交换机的作用，交换机上有很多的网络接口，把一个子网中的设备连接起来。</p>
<p>交换机本身是没有MAC地址或IP地址的，它的任务就是将接收到的网络包原样转发到目的地。交换机中维护了一个MAC地址的映射表<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/MAC%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E8%A1%A8.png" alt="MAC地址映射表"><center><em>图片来源于网络</em></center></p>
<p>举个例子，如果收到的包的接收方 MAC 地址为 00-60-97-A5-43-3C，则与图中表中的第 1 行匹配，根据端口列的信息，可知这个地址位于 1 号端口上，然后就可以通过交换电路将包发送到相应的端口了。</p>
<blockquote>
<p>如果 MAC 地址表找不到指定的 MAC 地址会怎么样？</p>
</blockquote>
<p>地址表中找不到指定的 MAC 地址。可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。</p>
<p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。</p>
<p>这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后只有相应的接收者才接收包，而其他设备则会忽略这个包。</p>
<p>有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”</p>
<p>其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。</p>
<p>局域网中每秒可以传输上千个包，多出一两个包并无大碍。</p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>网络包经过交换机转发后，就到达了路由器，数据包在此被转发到下一个路由器或者目标机器。</p>
<p>转发过程与交换机比较类似，也是通过查表来确定将数据包转发给谁，不过这里查的是<code>路由表</code>。</p>
<p>并且路由器与交换机有所不同</p>
<ul>
<li>交换机是基于以太网设计的，俗称<strong>二层网络设备</strong>，它本身没有IP地址和MAC地址</li>
<li>路由器是基于IP设计的，俗称<strong>三层网络设备</strong>，路由器的各个端口都有自己的IP地址和MAC地址</li>
</ul>
<p>网络包到达路由器后，路由器会解开其中的接收方MAC地址，与自己的MAC地址对比，如果确定接收方是自己，则接收这个网络包，否则丢弃。接收网络包后，继续解析其中的目标IP，查询<code>路由表</code>判断通过哪个接口转发。路由表的结构大概如下图所示：<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/%E8%B7%AF%E7%94%B1%E8%A1%A8.png" alt="在这里插入图片描述"><br>通过查表，如果“网关”列为空，说明目标地址与路由器在同一子网内，无需再发送到其他路由器进行转发，则目标IP就是当前的目标地址。</p>
<p>如果“网关”不为空，说明目标地址不在当前子网内，还需要通过网关进行转发，那么目标IP则是网关的IP。</p>
<p>知道了下一目标的IP后，路由器继续通过ARP协议获取目标的MAC地址，将网络包中的接收方与发送方MAC地址进行更新，这里我们假设包还没有到达终点。</p>
<p>发送出去的网络包会通过交换机到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p>
<p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p>
<blockquote>
<p>不知你发现了没有，在网络包传输的过程中，源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行两个设备之间的包传输。</p>
</blockquote>
<h2 id="抵达目标服务器"><a href="#抵达目标服务器" class="headerlink" title="抵达目标服务器"></a>抵达目标服务器</h2><p>数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。</p>
<p>接着继续扒开数据包的 IP 头，发现 IP 地址符合，并且知道了对方使用的协议，以及要访问的端口，于是把数据包的内容发给了HTTPS进程。</p>
<p>HTTPS进程拿到数据后，根据消息内容，知道了我们想要访问的是&#x2F;2025&#x2F;05&#x2F;15&#x2F;homepage这个文件，于是将这个文件的内容打包后再次发出。</p>
<hr>
<p>数据包通过同样的步骤，经过交换机、路由器层层转发，最终回到我们的电脑。</p>
<p>至此，我们就可以在我们的浏览器上看到要访问的页面了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alleys31.github.io/2025/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小王同学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小王的小窝">
      <meta itemprop="description" content="小王的各种日常记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 小王的小窝">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">计算机网络入门（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-15 20:12:35" itemprop="dateCreated datePublished" datetime="2025-05-15T20:12:35+08:00">2025-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-18 21:16:44" itemprop="dateModified" datetime="2025-05-18T21:16:44+08:00">2025-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">技术博客</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算机网络入门（一）"><a href="#计算机网络入门（一）" class="headerlink" title="计算机网络入门（一）"></a>计算机网络入门（一）</h1><p>我们的日常生活中，每天都在使用互联网，那你是否想过，“网络”到底是什么东西？网络中的两台计算机又是怎样实现互相交流的呢？</p>
<h2 id="网络是什么？"><a href="#网络是什么？" class="headerlink" title="网络是什么？"></a>网络是什么？</h2><p>两台计算机需要交流信息&#x2F;共享资源&#x2F;传输数据，归根结底一定是需要通过物理介质去传输的。我们把多台计算机和其他网络设备，通过线路连接在一起，这些设备组成的一个可以共享资源和信息的系统就叫做网络。</p>
<h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>物理上的连接组成了网络的骨架，但是想要实现数据的传输，仅有这些骨架是不够的，在实际应用中，我们会遇到各种各样的问题，不知道你们有没有想过，比如：</p>
<ul>
<li>我们知道，计算机只能发送和接受0&#x2F;1的电信号，而我们需要传输的数据是多种多样的，可能是语言文字、图形、声音等各种形式，那么在发送时，一定需要把这些数据转换为电信号，接收方接收到这些电信号后，再把它们翻译为原本的格式，这个转化及翻译的方式该如何定义呢？</li>
<li>互联网中有数以亿计的网络设备，我怎么才能精准定位并把数据准确无误的发送到我想发送的设备呢？</li>
<li>一台计算机上运行着很多的应用程序，在接收到一些数据时，计算机是怎么区分这些数据是发送给哪个应用程序的呢？</li>
<li>网络设备全都需要用物理线路连接起来，接口该如何统一呢？假设各种网络设备的接口没有统一的标准，各不相同，那连接他们需要的线缆也会五花八门，对于一个网络设备而言，如果它想要适配两种网络设备，那就需要预留两个不同形式的接口，那如果是数以亿计的网络设备呢？那适配工作一定是灾难性的……</li>
</ul>
<p>为了解决我们遇到的这些问题，在网络通信的每一个环节，从软件到硬件，都需要制定一些规则和标准，这些标准就叫做<code>网络协议</code>。</p>
<h2 id="网络的五层结构"><a href="#网络的五层结构" class="headerlink" title="网络的五层结构"></a>网络的五层结构</h2><p>我们上述思考的问题，代表了网络通信过程中不同的环节和角度，在网络通信的每一个环节中，都需要定义若干规则与标准，为了便于管理，计算机网络通常采用分层结构，每一层都承担了不同的责任，考虑不同的问题。</p>
<p>ISO（国际标准化组织）提出了OSI（Open Systems Interconnection，开放系统互联）模型，将网络分为七层，但是七层模型较为理论化，多用于理论研究，在实际生产中，通常采用简化的五层结构模型，也称为TCP&#x2F;IP模型。这五层分别是物理层、数据链路层、网络层、传输层和应用层。每一层都有其特定的功能和协议，共同协作以实现数据的传输和通信。</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>我们刚刚说过，要实现网络通信，在本质上，通信双方一定需要通过物理介质连接起来，网络设备之间可以通过双绞线、光纤、无线电波等方式连接，这就是物理层负责的功能。</p>
<p>物理层是网络结构的最底层，它定义了电气、机械、功能和规程特性，以确保数据能够通过物理媒介（如电缆、光纤等）进行传输。物理层的主要任务包括导线的标准、网络接口的形状、引脚排列、信号的编码、调制、传输和接收等。</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>通过物理层，我们已经可以将电信号从一方发送到另一方了，但是单纯的0&#x2F;1信号是没有任何意义的，必须规定电信号的解读方式：多少个电信号为一组，每组中每一位代表什么含义？</p>
<p>这就是数据链路层的功能，它规定了0和1的分组方式。</p>
<p><strong>以太网与MAC地址</strong></p>
<p>早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</p>
<p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。</p>
<p>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p>
<p>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p>
<p>上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？</p>
<p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这个地址就叫做<code>MAC地址</code>。每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。</p>
<p><strong>广播</strong></p>
<p>现在，网络中的每一块网卡都有了自己的MAC地址，那么，一块网卡在发送消息时，怎么才能准确的将消息传递到目标网卡上呢？</p>
<p>以太网采用了一种很“原始”的方式：广播</p>
<blockquote>
<p>不需要准确的将消息传递到目标网卡上，而是无差别发送，将数据发送到网络中的每一个设备上，各个设备根据标头中的接收方信息，判断自己是否为接收方，如果是，则接受该消息，如果不是，则丢弃。</p>
</blockquote>
<p>有了数据链路层的这些协议，现在我们已经可以实现在两个网络设备之间进行简单的通信了。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>在数据链路层中，依靠MAC地址发送数据。理论上，单单依靠MAC地址，就可以实现任意两个网卡之间的通信了，技术上是可以实现的。</p>
<p>但是实际上，互联网的组织方式并不是简单地将所有设备连接在一块，<em><strong>互联网是无数子网络共同组成的一个巨型网络</strong></em>，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。<br>而且，通过广播的形式传递消息，网络中的设备人手一“包”，网络传输的效率也极低。</p>
<p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送，而MAC地址本身是不具备这个能力的。</p>
<p>于是就有了网络层，它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</p>
<p>这样，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是与网卡有关，出厂即确定，而网络地址则是网络管理员分配的，它们只是随机组合在一起。</p>
<p>负责规定网络地址的协议叫做IP协议，因此网络地址又叫IP地址。</p>
<p>IP地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理IP地址，然后再处理MAC地址。</p>
<p>IP地址的具体形式，以及如何判断两个IP地址是否位于同一子网络中的方法，我们后续介绍，本文仅为五层结构的入门，介绍各个层负责的功能。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p>
<p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p>
<p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p>
<p>传输层的功能，就是建立<code>&quot;端口到端口&quot;的通信</code>。相比之下，网络层的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>通过上面四层的协作，我们已经实现了将数据从一个程序发送到另一台主机上的指定程序，接下来需要确定的自然就是这些数据包含的到底是什么信息，是一个邮件，还是一个图片，或者是一个视频呢？</p>
<p>这就是应用层负责的功能，应用层是网络结构的最高层，直接为用户提供网络服务。它包含各种应用程序和协议，如HTTP（HyperText Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）和DNS（Domain Name System）。应用层协议定义了数据格式和通信规则，以便应用程序之间能够通过网络进行交互。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们对网络的五层结构模型有了一个大致的了解，了解了网络是如何构成的，以及每一层分别实现了什么功能。后面我们将会继续深入探索，详细学习网络结构中一些重要的协议与实现细节。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">小王同学</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">10k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">9 分钟</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
